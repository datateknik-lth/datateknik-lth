\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[swedish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{enumerate}
%------------------------------------------
% For source code
%------------------------------------------
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

%------------------------------------------

\title{Sammanfattning EDA040}
\author{Felix Mulder}
\begin{document}
\maketitle
\newpage


\section{Deadlock Analysis}
Resource allocation graphs are used to determine if a program can deadlock.
For a program to end up in a deadlock there are a few requirements.
\begin{itemize}
  \item Mutual exclusion: at least one resource is held in a non-shareable mode.
  \item Hold and wait: there must exist a process that is holding at least one
        resource and simultaneously waiting for resources that are held by other
        processes.
  \item No preemption: resources cannot be preempted; the resource can only be 
        released voluntarily by the resource holding it.
  \item Circular wait: There must exist a set of processes waiting for each other
        in a circular structure. I.e: p1 waits for p2, p2 waits for p3, p3 waits
        for p1.
\end{itemize}

To draw a resource allocation graph from source code:
\begin{enumerate}
  \item Draw boxes for each resource.
  \item For each thread (i) and line (j), draw a bubble with $T_{ij}$. If a thread
        takes, then draw a line to the resource. For $T_{i(j+1)}$ draw a line from the
        resource to the thread.
  \item If $T_{ij}$ only emits or only absorbs arrows, you don't have to keep
        it in the graph.
  \item For resources that exist as multiple instances, draw dots inside the resource.
        If a cycle exists containing a multiple instance resource, then it may be a
        false cycle.
\end{enumerate}

Cycles in the graph indicate the possibility of deadlocks.
\begin{center}
  \includegraphics[scale=0.2]{res_alloc}
\end{center}

\section{Process synchronization}
\subsection{Dekker's Algorithm}
Dekker's algorithm solves the process synchronization problem with busy waits.
Meaning: using the below specified code results in a correctl handling of
critical areas. Alas, the threads spend CPU cycles in the while loop, needlessly.
If we implement Dekker's we should compliment it with wait/notify functionality.

\begin{lstlisting}[label=dekkers,caption=Dekker's Algorithm]
public class Dekkers extends MutualExclusion {
  public Dekkers () {
    flag[0] = false;
    flag[1] = false;
    turn = TURN_0;
  }

  public void enteringCriticalSection (int t) {
    int other;

    other = 1 - t;

    flag[t] = true;
    turn = other;

    while ((flag[other] == true) && (turn == other)) {
      Thread.yield();
    }
  }

  public void leavingCriticalSection (int t) {
    flag[t] = false;
  }

  private volatile int turn;
  private volatile boolean[] flag = new boolean[2];
}
\end{lstlisting}

\subsection{Race condition}
A race condition is when multiple threads access and manipulate the same
data concurrently, and where outcome of the execution depends on the
particular order in which access takes place.

\subsection{Mutual Exclustion}
If thread $T_i$ is executing in its critical section, then no other threads
can be executing in their critical sections.

\subsection{Progress}
If no thread is executing in its critical section and there exist threads
that wish to enter their critical sections, then only the threads not executing
in their critical section get to partake in the process of deciding which
thread gets to execute its critical section next.

\subsection{Starvation}
When some threads are allowed to execute and make progress, but others are
left ``starving.''

\subsection{Bounded waiting}
There exists a limit to the amount of times a thread will wait for other
threads before its request to enter a critical area is granted. (This
prevents starvation in a single thread.)

\subsection{Drifting}
The following piece of code will cause accumulative drift.
\begin{lstlisting}[label=dekkers,caption=Dekker's Algorithm]
while (!isInterrupted()) {
              sleep(100); foo.bar();
}
\end{lstlisting}

Sleep specifies a minimun time to sleep, and a context switch may have ocurred
after sleep and before the method call thus drift is accumulated.

\end{document}
