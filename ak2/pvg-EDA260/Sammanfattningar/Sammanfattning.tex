\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[swedish]{babel}

\usepackage[applemac]{inputenc}

\usepackage{fancyvrb}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{boiboites}
\usepackage{color}
% hyperreg för länkar typ url
\usepackage{hyperref}

% Minskar margins
\usepackage{fullpage}

\title{PvG}
\author{Philip Larsson}
\date{\today}

\newboxedtheorem[boxcolor=orange, background=blue!5, titlebackground=blue!20,
titleboxcolor = black]{tips}{Tips}{anything}

\newboxedtheorem[boxcolor=cyan, background=blue!5, titlebackground=blue!20,
titleboxcolor = black]{verktyg}{Verktyg}{anything2}


\begin{document}
\maketitle


\tableofcontents
\newpage


\section{Extreme Programming}
XP är en agil\footnote{agil: lättrörlig, vig} metod för hur man utvecklar programvara. \\
Mål med XP är kod med mycket hög kvalité och kod som kan ändras i takt med ändrade krav. 
\subsection{XP's deltekniker}
\subsubsection*{Kodning och design}
\begin{itemize}
\item{Enkel design}
\item{Refaktorisering}
\item{Kodningsstandard}
\item{Gemensam vokabulär}
\end{itemize}
\subsubsection*{Utveckling}
\begin{itemize}
\item{Test-driven utveckling (TDD)}
\item{Parprogrammering}
\item{Kollektivt kodägande}
\item{Kontinuelig integration}
\end{itemize}
\subsubsection*{Planering}
\begin{itemize}
\item{Kund i teamet}
\item{Planeringsspelet}
\item{Regelbundna releaser}
\item{Hållbart tempo}
\end{itemize}
\subsubsection*{Dessutom}
\begin{itemize}
\item{Gemensamt utvecklingsrum}
\item{Nollte iterationen}
\item{Spikes}
\end{itemize}
\subsubsection{XP Practices}
Från Artikel av Kent Beck (i häftet).
\begin{itemize}
\item{Planning game}
\item{Small releases}
\item{Metaphor}
\item{Simple design (no duplicated code, few classes and methods)}
\item{Tests (unit tests)}
\item{Refactoring}
\item{Pair programming}
\item{Continuous ownership}
\item{Collective ownership}
\item{On-site customer}
\item{40-hour weeks}
\item{Open workspace}
\item{Just Rules}
\end{itemize}
\subsection{Planeringsspelet}
Ska svara på frågan ''Vad skall vi utveckla och hur lång tid tar det?'' \\
Kunden skriver användarfall/user stories. \\
Utvecklaren estimerar tid för varje story.

\subsection{Regelbundna releaser}
Releaser till kund ska göras ofta. \\
Detta ger snabb feedback och kunden kan lätt påverka vidareutvecklingen.
\subsection{Kund i teamet}
En kund bör finnas på plats för att kunna kommunicera med utvecklarna. Personen behöver inte vara beställaren utan kan vara någon som representerar kunden och dess önskemål. 
\subsection{Gemensam vokabulär}
Samma vokabulär mellan kund och utvecklare. Använd gärna metaforer. 
\subsection{Testning}
Testning har en central del i XP. \\
Enhetstest (unit-tests) för varje klass/modul. Testfall skrivs \textbf{innan} motsvarande kod. Skrivs i små iterationer: testa..koda..testa..koda.. \\
Körs gärna automatiskt. 
\subsection{Kodning och design}
\subsubsection{Enkel design}
\begin{itemize}
\item{Ingen duplicerad kod.}
\item{Tydlig kod med bra namn.}
\item{Ingen onödig komplexitet.}
\item{Viktigt att programmet är lätt att förstå och ändra i.}
\end{itemize}
Designa för dagens behov, inte för eventuella behov i framtiden. \begin{quote}''Don't design och speculation''\end{quote}

\subsubsection{Refaktorisering}
Omstrukturering av kod utan att ändra beteendet. Exempel på metoder:
\begin{itemize}
\item[]{Rename Method: byta namn på metod.}
\item[]{Extract Method: bryt ut kod till egen metod.}
\item[]{Move Method: flytta en metod till en annan klass.}
\end{itemize}
Refaktorisering gör man för att förstå koden bättre. För att lättare kunna införa en ändring eller när koden börjar ''lukta illa''.
\subsection{Dokumentation}
XP fokuserar inte på dokumentation. Man använder endast enkel och informell dokumentation med enkla beskrivningar. Koden ska vara självförklarande, så god namngivning är ett måste. \\
Mer noggrann dokumentation kan tas fram i efterhand om kund önskar det.
\section{Arkitektur och planering} % ----------- NEW SECTION ----------
Mjukvaruarkitektur är den övergripande designen. Traditionell syn på arkitekturen är att den är svår att ändra. Därför planerar man och designar arkitekturen först. \\
I XP så accepterar man att förändringar är oundvikliga, och gör lite för att förhindra dessa. Istället omfamnar man dem när de sker.

\subsection{XP's grundläggande struktur / arkitektur}
\subsubsection*{Spikes}
Är experimentell prototyplösning. En eller två utvecklare skriver kod för att undersöka ett problem. Koden bör inte vara ren och enligt konstens alla regler - koden kommer att kastas sedan. 

\subsubsection*{System Metafor}
System metaphor är en liknelse som alla - kund, programmerare och chefer förstår. Används för att beskriva hur systemet fungerar.

\subsubsection*{Första Iterationen}
I den första iterationen så vill man bara ha ett minimalt system som kan köras, med minimal funktionalitet. Man väljer några enkla grundläggande stories som man tror kommer att leda till att man har en grundläggande struktur. 

\subsubsection*{Små releases}
Korta releasecykler har flera fördelar. Kunden ser vid varje release hur arbetet framskrider (och vad hon betalar för). Korta releasecykler leder även till feedback som gör att man snabbt kan ändra om man t.ex. har missförstått kunden, eller om kunden bara har ändrat sin åsikt. 

\subsubsection*{Refaktorisering}
Håller koden i konstant bra skick.

\subsection{The Planning Game}
\begin{itemize}
\item{Kunden skriver ner features på story cards.}
\item{Utvecklarna delar upp story:na i tasks.}
\item{Utvecklarna uppsattar tidsåtgång för varje taks.}
\item{Kunden väljer tasks för att fylla hela nästa iteration. Resterande tasks sparas till nästa iteration.}
\end{itemize}
\subsection{Prioriteringar vid programvaruutveckling}
Av de fyra storheterna:
\begin{itemize}
\item{Bemanning, antal utvecklare}
\item{Tidsåtgång, kalendertid}
\item{Funktioner hos systemet}
\item{Kvalitet på funktionaliteten}
\end{itemize}
Kan man vid programvaruutveckling bara välja tre. \\
XP håller fast vid tre: bemanning, tidsåtgång och kvalité, men låter funktion variera. \\ 
Andra utvecklingsmetoder låter tid variera, vilket kan leda till att det ej är klart i tid. 

\subsection{Problem vid utvecklingen}
I traditionella utvecklingsmetoder är potentiella problem att systemet inte blir klart i tid. Det man gör då är att tillsätta mer personal, men inledningsvis så kommer projektet att stå still och fördröjas ännu mer, då de ''gamla'' måste lära upp de nya. \\ \\
I XP är potentiella problem att vi inte får med alla funktioner. De väsentligaste funktionerna \emph{bör} vara med, då det är dessa man börjar med. Men, om önskvärda funktioner ändå saknas, kan detta lösas genom att tillsätta mer personal. Upplärningen av den nya personalen bör gå snabbare än i traditionell utveckling på grund av parprogrammeringen. 
\section{Konfigurationshantering} % ----------- NEW SECTION ----------
\textbf{SCM}: Software Configuration Management \\
\textbf{CVS}: Concurrent versions system (CVS) är ett vida spritt och mycket populärt system för versionshantering, speciellt i projekt baserade på öppen källkod. \footnote{ \url{http://sv.wikipedia.org/wiki/Concurrent_versions_system} 
} \\
\textbf{Git}: Git är ett versionshanteringsprogram som skapades 2005 för att hantera källkoden till Linuxkärnan. Linus Torvalds ansåg att inget av de alternativ som fanns att tillgå räckte till vad gäller funktion eller prestanda. \footnote{ \url{http://sv.wikipedia.org/wiki/Git}}
\subsection{CVS Overview}
Källkoden sparas i ett \emph{repository} på en server. Ändringar görs i lokala \emph{workspace}. Det lokala workspacet skapas via en \emph{check out}, och görs bara en gång. Då kopieras filer från repositoryt till den egna lokala datorn (lokala workspacet). \\
Efter att utvecklaren har ändrat i någon fil kan hon göra en \emph{commit} för att ladda upp den nya versionen. \\
Utvecklaren kan även göra en \emph{update} för att kopiera de senaste filerna från repositoryt till eget lokalt workspace. \\ \\
Repositoryt sparar alla versioner av filerna så att man ska kunna gå tillbaka om det behövs. Ett repository består av en eller flera moduler. Vanligtvis så är en modul ett projekt/program. 
\subsubsection{Vanliga kommandon}
\begin{itemize}
\item{\textbf{checkout}: skapa ett nytt workspace.}
\item{\textbf{update}: uppdatera workspacet, dvs. kopiera nya filer från repositoryt till workspacet.}
\item{\textbf{kommit}: ladda upp ändrade filer från repositoryt.}
\end{itemize}
\begin{tips}[]
\textbf{Viktiga arbetsvanor:}
\begin{itemize}
\item{Se till så att den senaste versionen av repositoryt alltid fungerar, dvs. kompilerar och alla test är gröna.}
\item{\emph{Update} ofta, så att man alltid har den senaste versionen.}
\item{\emph{Update} \textbf{alltid} innan \emph{commit}.}
\item{\emph{Commit} ofta, så att andra utvecklare kan få senaste versionen.} 
\end{itemize}
\end{tips}
\subsection{Git}
Som CVS, men även med ett lokalt repository. Kommandona skiljer sig åt.
\subsubsection{Kommandon}
\begin{itemize}
\item{\textbf{clone}: ungefär som cvs \emph{checkout}. Skapar både ett lokalt repository samt tillhörande workspace.}
\item{\textbf{pull}: ungefär som cvs \emph{update}. Hämtar filer från (globalt) repo till eget workspace.}
\item{\textbf{commit}: laddar ändringar till eget (lokalt) repo.}
\item{\textbf{push}: ungefär som cvs \emph{commit}. Laddar upp filerna från lokalt repo till globalt repo.}
\end{itemize}
\subsubsection{Fördelar med Git och eget lokalt repo}
\begin{itemize}
\item{Du kan arbeta lokalt och commit:a till eget repo utan nätverksåtkomst.}
\item{Du kan skapa egna repositorys lokalt, så att man kan få alla fördelar med version control för eget projekt.}
\item{Om den globala servern krashar, kan man fortfarande jobba på lokalt.}
\end{itemize}
\begin{tips}[]
Precis som att man alltid ska göra en \textbf{update} innan \textbf{commit} i CVS, så bör man göra \textbf{pull} innan man gör \textbf{commit} och \textbf{push} i Git.
\end{tips}

\subsection{SCM och XP}
Bidrar till
\begin{itemize}
\item{hantera källkod}
\item{delat kodägandeskap}
\item{simpel integration}
\item{smärtfri refaktorisering}
\item{enkelt att testa}
\item{enkelt att göra releaser}
\item{hantera dokumentation}
\end{itemize}
\subsection{Mål med SCM}
\begin{itemize}
\item{Att kunna gå till baka till fungerande ''states''.}
\item{Att ha en överblick över mjukvarans utvecklings-historik.}
\item{Visa vad som beror på vad.}
\item{Hjälpa människor att samordna sitt arbete.}
\end{itemize}
\subsection{3 Typiska problem som visar varför SCM behövs}
\begin{itemize}
\item[]{\textbf{Double maintenance} \\
	Problemet är att ha flera identiska kopior av samma mjukvara, då det är svårt och ha alla uppdaterade. Vi löser detta genom att undvika multipla kopior av samma version.}
\item[]{\textbf{Shared data} \\
	Problemet att flera personer beror på och redigerar samma data (kod). När en programmerare gör ändringar i en fil, kan de ändringarna förstöra för andra programmerare.}
\item[]{\textbf{Simultaneous update} \\
	När två personer samtidigt jobbar med samma fil och sedan uppdaterar är det möjligt att en persons uppdateringar blir överskrivna.}
\end{itemize}

\section{Testning} % ------------- NEW SECTION -------------
\subsection{Testnivåer}
Hur mycket av systemet är inblandat i testerna?
\begin{itemize}
\item{Enhetstest, t.ex. en klass}
\item{Modultest, t.ex. ett paket}
\item{Subsystem, t.ex. ett lager}
\item{Systemtest (hela systemet)}
\end{itemize}
\subsection*{Enhetstest och acceptanstest}
Man brukar dela upp tester i två kategorier, enhetstest och acceptanstest.
\begin{itemize}
\item{\emph{Enhetstest} (eller utvecklartest). Testar delar av koden.}
\item{\emph{Acceptanstest} (eller kund test). Testar så att önskade features fungerar och lever upp till kundens önskemål.}
\end{itemize}


\subsection{Testdriven utveckling i XP}
\begin{itemize}
\item{Skriv ett test.}
\item{Kompilera testet. Det ska misslyckas eftersom koden som testet anropar inte finns än.}
\item{Implementera bara tillräckligt för att kompilera.}
\item{Kör testet och se det misslyckas.}
\item{Implementera minsta möjliga så att testet blir grönt.}
\item{Kör testet och se så det blir grönt.}
\item{Refaktorisera.}
\item{Om man använder ett SCM: \emph{update} och \emph{commit}.}
\item{Börja om från början!}

\end{itemize}

\section{Parprogrammering} % ------------- NEW SECTION -------------
Två personer som sitter vid samma maskin. Den som skriver kod brukar kallas för \emph{Föraren} (Driver) och den andra kallas för \emph{Navigatör}. 
\subsection*{Föraren}
\begin{itemize}
\item{Skriver kod.}
\item{Beskriver vad han gör, typ ''Här behöver vi en temporär variabel för att beräkna summan." \footnote{Två fördelar med att beskriva högt vad man gör: \begin{itemize}\item{Vi kan hitta fel/brister i koden bara genom att förklara för någon annan.} \item{Det håller navigatören engagerad eftersom båda parter kommunicerar.}\end{itemize}} }
\end{itemize}

\subsection*{Navigatören}
\begin{itemize}
\item{Granskar koden efter fel (ex. felstavningar, fel metodanrop, syntaxfel).}
\item{Ger direct feedback på design, metodnamn m.m.}
\item{Håller reda på todo listan.}
\item{Föreslår förbättringar.}
\end{itemize}

\subsection{Parprogrammeringstips}
\begin{itemize}
\item{Byt partner ofta.}
\item{Tala i Vi-termer istället för Du-termer. ''Vi gjorde fel här och bör göra såhär istället..''.}
\item{Driver 
	\begin{itemize}
	\item{Var lyhörd.}
	\item{Rusa inte iväg, se till så att partnern förstår.}
	\end{itemize}
	}
\item{Navigatören
	\begin{itemize}
	\item{Hitta förarens rytm.}
	\item{Föreslå rollbyte om ni kör fast.}
	\end{itemize}
	}
\item{Ta Pauser \\
	Minimum att varje timme: Stå upp, stretcha och titta på något som är mer än en meter bort.}
\item{Var ödmjuk \begin{itemize}
	\item{Lyssna och diskutera.}
	\item{Lär av partnern och lär ut till partnern.}
	\end{itemize}}
\end{itemize}
\section{Enkel design} % ------------- NEW SECTION -------------

\subsection*{Kod med enkel design är}
\begin{itemize}
\item{Tydlig och lättbegriplig.}
\item{Har inte någon duplicerad kod.}
\item{All komplexitet skall vara motiverad av dagens behov - testfallen.}
\end{itemize}
\subsubsection*{Exempel på icke-enkel design}
\begin{itemize}
\item{Krånglig kod, obegripliga namn.}
\item{Copy-paste kod.}
\item{Klass och metodskelett som inte används än.}
\item{Patterns som används i ''onödan'', innan de verkligen behövs.}
\end{itemize}
\subsection*{Teknik för enkel design}
Tydlig lättbegriplig kod är kod man ska kunna första utan att först dechiffrera den. \\
Detta får vi med t.ex:
\begin{itemize}
\item{Goda val av namn på t.ex. variabler, klasser, metoder..}
\item{Namnge värden och beräkningar (som variabler och metoder) - istället för att bara koda algoritmen direkt. Alltså att spara delsteg i algoritmen och namnge variabeln så att man enkelt förstår vad som händer.}
\item{Varje metod skall vara så liten och enkel att man lätt kan förstå vad som händer i den, och så att den är enkel att namnge.}
\item{Varje variabel och klass skall användas till ett väldefinierat ändamål (så att den är enkel att namnge).}
\item{Namn ska uttrycka vad objektet innehåller, inte hur.}
\end{itemize}
\subsection*{Komplex kod med enkel design}
En enkel design kan vara komplex om problemet vi försöker lösa är komplext. \\
Men designen är ''enkel'' om:
\begin{itemize}
\item{Varje ide är explicit i koden.}
\item{Det inte finns duplicerad kod.}
\item{All komplexitet i koden är motiverad av testfallen.}
\end{itemize}
\subsection{Code Smells}
Code smells är symptom i koden som antyder om bristfällig design. \\
Exempel på code smells:
\begin{itemize}
\item[]{\textbf{Duplicerad kod} \\
	Om samma kod används på flera ställen blir koden bättre om det går att kombinera den duplicerade kod-biten och bara ha den på ett ställe.}
\item[]{\textbf{Long method} \\
	Vi vill inte ha för långa metoder som gör flera saker samtidigt. Bättre att dela upp i flera mindre metoder. \\ 
	Ett block av kod med en kommentar som berättar vad koden gör kan oftast ersättas av en metod. Metodens namn ska ersätta kommentaren, och då vara tillräckligt bra för förklara i stort sätt samma sak som den tidigare kommentaren.} 
\item[]{\textbf{Large Class} \\
	När en klass försöker göra för mycket syns det ofta på för många instans/member variabler. Man bör i så fall försöka bryta ut liknande metoder i en egen klass.}
\item[]{\textbf{Large Paramer List} \\
	Långa parameter-listor är svåra att förstå och underhålla. \\
	Försök att istället låta metoder göra anrop på objektet och på så sätt få tag på värden. Detta är bättre än att skicka in sagda värden som parametrar i metoden.}
\end{itemize}
\section{Refaktorisering} % ------------- NEW SECTION -------------

Refaktorisering: omstrukturering av koden utan att ändra det yttre beteendet. \\ \\
Syftet med refaktorisering är att göra mjukvaran enklare att ändra och förstå. Refaktoriseringen ändrar inte det observerbara beteendet av mjukvaran. \\ \\
Man bör refaktorisera hela tiden när man utvecklar mjukvara. Det är inte något som man avsätter tid till att göra, utan det är en viktig del i själva utvecklingsprocessen som bör ske reflexmässigt.
\subsubsection*{Syftet med refaktorisering}
\begin{itemize}
\item{Regelbunden refaktorisering håller koden i ''trim''. Utan regelbunden faktorisering så kommer koden att förfalla.}
\item{Refaktoriseringen gör så att koden blir lättare att förstå. Det är bättre att skriva tydlig kod som är lätt att förstå men kanske tar några klockcykler längre tid att köra än att skriva ''snabbare'' kod som tar veckor att förstå. Tänk på att i XP äger alla koden så det är mycket möjligt att någon annan kommer att läsa din kod.}
\item{Refaktorisering hjälper dig att hitta buggar. När man refaktoriserar koden så förtydligar man koden och då är det enklare att hitta buggar.}
\item{Refaktoriseringen hjälper dig att programmera snabbare. Utan god design, kan man utveckla mjukvara snabbt tills det att den dåliga designen reducerar tempot. En bra design är avgörande för att bibehålla tempot i utvecklingen.}
\end{itemize}

\end{document}













